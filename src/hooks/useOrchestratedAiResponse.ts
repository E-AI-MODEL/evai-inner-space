
import { useOpenAI, EmotionDetection } from './useOpenAI';
import { useOpenAISecondary } from './useOpenAISecondary';
import { useOpenAISeedGenerator } from './useOpenAISeedGenerator';
import { Message, ChatHistoryItem } from '../types';
import { useState } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { AdvancedSeed } from '../types/seed';
import { toast } from '@/hooks/use-toast';

export function useOrchestratedAiResponse(apiKey: string, apiKey2?: string) {
  const { detectEmotion, isLoading } = useOpenAI();
  const { analyzeNeurosymbolic, generateSeed } = useOpenAISecondary();
  const { injectSeedToDatabase } = useOpenAISeedGenerator();
  const [isProcessing, setIsProcessing] = useState(false);

  const analysisPhase = (messages: Message[]): ChatHistoryItem[] => {
    return messages.slice(-6).map(m => ({
      role: m.from === 'user' ? 'user' as const : 'assistant' as const,
      content: m.content,
      from: m.from
    }));
  };

  const strategyPhase = (_history: ChatHistoryItem[]) => {
    return {};
  };

  const promptPhase = async (
    userMessage: Message,
    history: ChatHistoryItem[]
  ): Promise<EmotionDetection> => {
    return detectEmotion(userMessage.content, apiKey, undefined, history);
  };

  const enhancementPhase = async (
    userMessage: Message,
    history: ChatHistoryItem[],
    primaryResponse: EmotionDetection
  ): Promise<{ 
    analysisData: {
      gapAnalysisFeedback: string;
      symbolicInferences: string[];
      autoGeneratedSeed?: AdvancedSeed;
    };
  }> => {
    if (!apiKey2?.trim()) {
      return { 
        analysisData: {
          gapAnalysisFeedback: '',
          symbolicInferences: primaryResponse.symbolicInferences || []
        }
      };
    }

    try {
      // Run secondary neurosymbolic analysis
      const contextString = history.map(h => `${h.role}: ${h.content}`).join('\n');
      const analysis = await analyzeNeurosymbolic(
        userMessage.content,
        contextString,
        apiKey2
      );

      let gapAnalysisFeedback = '';
      let symbolicInferences = primaryResponse.symbolicInferences || [];
      let autoGeneratedSeed: AdvancedSeed | undefined;

      if (analysis) {
        // Create gap analysis feedback (for admin/transparency only)
        const patterns = analysis.patterns.slice(0, 2).join(', ');
        const insights = analysis.insights.slice(0, 2).join(', ');
        
        gapAnalysisFeedback = `Gap Analyse: Gedetecteerde patronen: ${patterns}. Inzichten: ${insights}. Betrouwbaarheid: ${Math.round(analysis.confidence * 100)}%.`;

        // Add symbolic inferences from secondary analysis
        symbolicInferences = [
          ...symbolicInferences,
          ...analysis.patterns.slice(0, 2),
          ...analysis.insights.slice(0, 1)
        ];

        // Auto-generate and inject seed if suggestion found
        if (analysis.seedSuggestion && Math.random() > 0.3) {
          console.log('ðŸŒ± Auto-generating seed for:', analysis.seedSuggestion);
          
          const generatedSeedResponse = await generateSeed(
            analysis.seedSuggestion,
            `Automatische seed generatie gebaseerd op conversatie analyse: ${analysis.insights.join(' ')}`,
            apiKey2
          );

          if (generatedSeedResponse) {
            autoGeneratedSeed = {
              id: uuidv4(),
              emotion: analysis.seedSuggestion,
              type: 'validation',
              label: 'Valideren',
              triggers: [analysis.seedSuggestion, ...analysis.patterns.slice(0, 2)],
              response: { nl: generatedSeedResponse },
              context: { severity: 'medium', situation: 'therapy' },
              meta: { 
                priority: 1, 
                weight: 1.0, 
                confidence: analysis.confidence, 
                usageCount: 0,
                ttl: 43200
              },
              tags: ['auto-generated', 'api2-enhanced', 'gap-analysis'],
              createdAt: new Date(),
              updatedAt: new Date(),
              createdBy: 'ai-api2',
              isActive: true,
              version: '2.1.0'
            };

            // Inject seed automatically
            const injected = await injectSeedToDatabase(autoGeneratedSeed);
            if (injected) {
              console.log('âœ… Auto-generated seed injected:', analysis.seedSuggestion);
              toast({ title: 'Nieuwe seed toegevoegd', description: autoGeneratedSeed.emotion });
            }
          }
        }
      }

      return { 
        analysisData: {
          gapAnalysisFeedback,
          symbolicInferences,
          autoGeneratedSeed
        }
      };
      
    } catch (error) {
      console.error('ðŸ”´ Enhancement phase error:', error);
      return { 
        analysisData: {
          gapAnalysisFeedback: '',
          symbolicInferences: primaryResponse.symbolicInferences || []
        }
      };
    }
  };

  const packagingPhase = (
    ai: EmotionDetection,
    enhancement: { 
      analysisData: {
        gapAnalysisFeedback: string;
        symbolicInferences: string[];
        autoGeneratedSeed?: AdvancedSeed;
      };
    }
  ): Message => ({
    id: `ai-${Date.now()}`,
    from: 'ai',
    label: ai.label,
    content: ai.response, // Only the clean primary response, no analysis leakage
    emotionSeed: ai.emotion,
    animate: true,
    timestamp: new Date(),
    feedback: null,
    // Analysis data stored for transparency tooltip and admin dashboard
    symbolicInferences: enhancement.analysisData.symbolicInferences,
    explainText: ai.reasoning,
    // Store gap analysis for admin dashboard (not shown in chat)
    meta: enhancement.analysisData.gapAnalysisFeedback ? {
      gapAnalysis: enhancement.analysisData.gapAnalysisFeedback,
      autoSeed: enhancement.analysisData.autoGeneratedSeed?.emotion
    } : undefined
  });

  const orchestrateResponse = async (
    userMessage: Message,
    historyMessages: Message[]
  ): Promise<Message | null> => {
    if (!apiKey.trim()) return null;
    setIsProcessing(true);
    try {
      const history = analysisPhase(historyMessages);
      strategyPhase(history);
      const ai = await promptPhase(userMessage, history);
      const enhancement = await enhancementPhase(userMessage, history, ai);
      return packagingPhase(ai, enhancement);
    } finally {
      setIsProcessing(false);
    }
  };

  return { orchestrateResponse, isProcessing: isProcessing || isLoading };
}
